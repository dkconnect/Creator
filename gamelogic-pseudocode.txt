// Algorithm 1 — Game Initialization
// Algorithm InitializeGame
// Input: Board size N, Pattern P_raw, PlayerMode
// Output: Initial game state G

1: Create board S as N × N matrix initialized to EMPTY
2: Embed pattern:
3:   P ← CenterAndEmbed(P_raw, N)
4: Place Creator pawns in rows 0 and 1
5: Place Destroyer pawns in rows N−2 and N−1
6: Set currentPlayer ← Creator
7: diceValue ← NULL
8: gameOver ← false
9: return G = (S, P, currentPlayer, diceValue)


// Algorithm 2 — Dice Roll
// Algorithm RollDice
// Input: Game state G
// Output: Updated dice value

1: diceValue ← RandomInteger(1,6)
2: if NoValidMoves(currentPlayer, diceValue) then
3:     SwitchTurn()
4: return diceValue


// Algorithm 3 — Valid Move Generation
// Algorithm GetValidMoves
// Input: Position (r,c), diceValue d, board S
// Output: Set of legal target cells M

1: M ← ∅
2: Directions ← { (±1,0), (0,±1), (±1,±1) }
3: for each (dr,dc) in Directions do
4:     r' ← r + dr × d
5:     c' ← c + dc × d
6:     if (r',c') inside board then
7:         if S[r'][c'] ≠ currentPlayer then
8:             Add (r',c') to M
9: return M


// Algorithm 4 — Execute Move
// Algorithm ExecuteMove
// Input: Source (r,c), Target (r',c'), Game state G

1: if S[r'][c'] contains opponent pawn then
2:     Send opponent pawn to spawn area
3: S[r'][c'] ← currentPlayer
4: S[r][c] ← EMPTY
5: if CheckWin(currentPlayer) then
6:     gameOver ← true
7: else
8:     SwitchTurn()


// Algorithm 5 — Win Condition
// Algorithm CheckWin
// Input: Player t, Board S, Pattern P
// Output: Boolean

1: for all cells (i,j) do
2:     if P[i][j] = 1 and S[i][j] ≠ t then
3:         return false
4: return true


// Algorithm 6 — AI Decision Engine (Overpowered Heuristic)
// Algorithm AI_Move
// Input: Game state G
// Output: Selected move

1: bestScore ← −∞
2: bestMove ← NULL
3: for each pawn p owned by AI do
4:     M ← GetValidMoves(p)
5:     for each move m in M do
6:         score ← EvaluateMove(p, m)
7:         if score > bestScore then
8:             bestScore ← score
9:             bestMove ← (p,m)
10: return bestMove


// Algorithm 7 — Heuristic Evaluation Function
// Algorithm EvaluateMove
// Input: Pawn p, Target cell m
// Output: Utility score U

1: U ← 0
2: if m overlaps pattern cell then
3:     U ← U + α
4: if m captures opponent pawn then
5:     U ← U + β
6: if m blocks opponent near-completion then
7:     U ← U + γ
8: if m increases opponent disruption entropy then
9:     U ← U + δ
10: return U


